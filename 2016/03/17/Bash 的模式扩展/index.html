<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#000000"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#000000"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.zwec.org","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="简介Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。 这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。  波浪线扩展 ? 字符扩展 * 字符扩展 方括号扩展 大括号扩展"><meta property="og:type" content="article"><meta property="og:title" content="Bash 的模式扩展"><meta property="og:url" content="http://www.zwec.org/2016/03/17/Bash%20%E7%9A%84%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95/index.html"><meta property="og:site_name" content="Zwec&#39; Blog"><meta property="og:description" content="简介Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。 这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。  波浪线扩展 ? 字符扩展 * 字符扩展 方括号扩展 大括号扩展"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2016-03-17T10:46:58.000Z"><meta property="article:modified_time" content="2022-09-07T06:07:57.028Z"><meta property="article:author" content="Zwec"><meta property="article:tag" content="Shell 学习"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://www.zwec.org/2016/03/17/Bash%20%E7%9A%84%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.zwec.org/2016/03/17/Bash%20%E7%9A%84%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95/","path":"2016/03/17/Bash 的模式扩展/","title":"Bash 的模式扩展"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Bash 的模式扩展 | Zwec' Blog</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Zwec' Blog</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">41</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A2%E6%B5%AA%E7%BA%BF%E6%89%A9%E5%B1%95"><span class="nav-number">2.</span> <span class="nav-text">波浪线扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%89%A9%E5%B1%95"><span class="nav-number">3.</span> <span class="nav-text">? 字符扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%89%A9%E5%B1%95-1"><span class="nav-number">4.</span> <span class="nav-text">* 字符扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="nav-number">5.</span> <span class="nav-text">方括号扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start-end-%E6%89%A9%E5%B1%95"><span class="nav-number">6.</span> <span class="nav-text">[start-end] 扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="nav-number">7.</span> <span class="nav-text">大括号扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start-end-%E6%89%A9%E5%B1%95-1"><span class="nav-number">8.</span> <span class="nav-text">{start..end} 扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%89%A9%E5%B1%95"><span class="nav-number">9.</span> <span class="nav-text">变量扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E5%91%BD%E4%BB%A4%E6%89%A9%E5%B1%95"><span class="nav-number">10.</span> <span class="nav-text">子命令扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E6%89%A9%E5%B1%95"><span class="nav-number">11.</span> <span class="nav-text">算术扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="nav-number">12.</span> <span class="nav-text">字符类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">13.</span> <span class="nav-text">使用注意点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8F%E8%AF%8D%E8%AF%AD%E6%B3%95"><span class="nav-number">14.</span> <span class="nav-text">量词语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shopt-%E5%91%BD%E4%BB%A4"><span class="nav-number">15.</span> <span class="nav-text">shopt 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">16.</span> <span class="nav-text">参考链接</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Zwec" src="/images/avatar.gif"><p class="site-author-name" itemprop="name">Zwec</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">41</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div class="sidebar-dimmer"></div></header><div class="reading-progress-bar"></div><a href="https://github.com/zwec" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://www.zwec.org/2016/03/17/Bash%20%E7%9A%84%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Zwec"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Zwec' Blog"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Bash 的模式扩展 | Zwec' Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Bash 的模式扩展</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2016-03-17 18:46:58" itemprop="dateCreated datePublished" datetime="2016-03-17T18:46:58+08:00">2016-03-17</time> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9.3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p><p>这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。</p><ul><li>波浪线扩展</li><li><code>?</code> 字符扩展</li><li><code>*</code> 字符扩展</li><li>方括号扩展</li><li>大括号扩展</li><li>变量扩展</li><li>子命令扩展</li><li>算术扩展</li></ul><p>本章介绍这八种扩展。</p><span id="more"></span><p>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。</p><p>模块扩展的英文单词是<code>globbing</code>，这个词来自于早期的 Unix 系统有一个<code>/etc/glob</code>文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。</p><p>模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p><p>Bash 允许用户关闭扩展。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">set</span> -o <span class="built_in">noglob</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ <span class="built_in">set</span> -f</span><br></pre></td></tr></table></figure><p>下面的命令可以重新打开扩展。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">set</span> +o <span class="built_in">noglob</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ <span class="built_in">set</span> +f</span><br></pre></td></tr></table></figure><h2 id="波浪线扩展"><a href="#波浪线扩展" class="headerlink" title="波浪线扩展"></a>波浪线扩展</h2><p>波浪线<code>~</code>会自动扩展成当前用户的主目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> ~</span><br><span class="line">/home/me</span><br></pre></td></tr></table></figure><p><code>~/dir</code>表示扩展成主目录的某个子目录，<code>dir</code>是主目录里面的一个子目录名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 /home/me/foo 目录</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/foo</span><br></pre></td></tr></table></figure><p><code>~user</code>表示扩展成用户<code>user</code>的主目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> ~foo</span><br><span class="line">/home/foo</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> ~root</span><br><span class="line">/root</span><br></pre></td></tr></table></figure><p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。</p><p>如果<code>~user</code>的<code>user</code>是不存在的用户名，则波浪号扩展不起作用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> ~nonExistedUser</span><br><span class="line">~nonExistedUser</span><br></pre></td></tr></table></figure><p><code>~+</code>会扩展成当前所在的目录，等同于<code>pwd</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/foo</span><br><span class="line">$ <span class="built_in">echo</span> ~+</span><br><span class="line">/home/me/foo</span><br></pre></td></tr></table></figure><h2 id="字符扩展"><a href="#字符扩展" class="headerlink" title="? 字符扩展"></a><code>?</code> 字符扩展</h2><p><code>?</code>字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code>匹配所有<code>Data</code>后面跟着三个字符的文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt 和 b.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> ?.txt</span><br><span class="line">a.txt b.txt</span><br></pre></td></tr></table></figure><p>上面命令中，<code>?</code>表示单个字符，所以会同时匹配<code>a.txt</code>和<code>b.txt</code>。</p><p>如果匹配多个字符，就需要多个<code>?</code>连用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt、b.txt 和 ab.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> ??.txt</span><br><span class="line">ab.txt</span><br></pre></td></tr></table></figure><p>上面命令中，<code>??</code>匹配了两个字符。</p><p><code>?</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录有 a.txt 文件</span></span><br><span class="line">$ <span class="built_in">echo</span> ?.txt</span><br><span class="line">a.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录为空目录</span></span><br><span class="line">$ <span class="built_in">echo</span> ?.txt</span><br><span class="line">?.txt</span><br></pre></td></tr></table></figure><p>上面例子中，如果<code>?.txt</code>可以扩展成文件名，<code>echo</code>命令会输出扩展后的结果；如果不能扩展成文件名，<code>echo</code>就会原样输出<code>?.txt</code>。</p><h2 id="字符扩展-1"><a href="#字符扩展-1" class="headerlink" title="* 字符扩展"></a><code>*</code> 字符扩展</h2><p><code>*</code>字符代表文件路径里面的任意数量的任意字符，包括零个字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt、b.txt 和 ab.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> *.txt</span><br><span class="line">a.txt b.txt ab.txt</span><br></pre></td></tr></table></figure><p>上面例子中，<code>*.txt</code>代表后缀名为<code>.txt</code>的所有文件。</p><p>如果想输出当前目录的所有文件，直接用<code>*</code>即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> *</span><br></pre></td></tr></table></figure><p><code>*</code>可以匹配空字符，下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt、b.txt 和 ab.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> a*.txt</span><br><span class="line">a.txt ab.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span> *b*</span><br><span class="line">b.txt ab.txt</span><br></pre></td></tr></table></figure><p>注意，<code>*</code>不会匹配隐藏文件（以<code>.</code>开头的文件），即<code>ls *</code>不会输出隐藏文件。</p><p>如果要匹配隐藏文件，需要写成<code>.*</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有隐藏文件</span></span><br><span class="line">$ <span class="built_in">echo</span> .*</span><br></pre></td></tr></table></figure><p>如果要匹配隐藏文件，同时要排除<code>.</code>和<code>..</code>这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成<code>.[!.]*</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> .[!.]*</span><br></pre></td></tr></table></figure><p>注意，<code>*</code>字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录不存在 c 开头的文件</span></span><br><span class="line">$ <span class="built_in">echo</span> c*.txt</span><br><span class="line">c*.txt</span><br></pre></td></tr></table></figure><p>上面例子中，当前目录里面没有<code>c</code>开头的文件，导致<code>c*.txt</code>会原样输出。</p><p><code>*</code>只匹配当前目录，不会匹配子目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子目录有一个 a.txt</span></span><br><span class="line"><span class="comment"># 无效的写法</span></span><br><span class="line">$ <span class="built_in">ls</span> *.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有效的写法</span></span><br><span class="line">$ <span class="built_in">ls</span> */*.txt</span><br></pre></td></tr></table></figure><p>上面的例子，文本文件在子目录，<code>*.txt</code>不会产生匹配，必须写成<code>*/*.txt</code>。有几层子目录，就必须写几层星号。</p><p>Bash 4.0 引入了一个参数<code>globstar</code>，当该参数打开时，允许<code>**</code>匹配零个或多个子目录。因此，<code>**/*.txt</code>可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面<code>shopt</code>命令的介绍。</p><h2 id="方括号扩展"><a href="#方括号扩展" class="headerlink" title="方括号扩展"></a>方括号扩展</h2><p>方括号扩展的形式是<code>[...]</code>，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，<code>[aeiou]</code>可以匹配五个元音字母中的任意一个。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt 和 b.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> [ab].txt</span><br><span class="line">a.txt b.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只存在文件 a.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> [ab].txt</span><br><span class="line">a.txt</span><br></pre></td></tr></table></figure><p>上面例子中，<code>[ab]</code>可以匹配<code>a</code>或<code>b</code>，前提是确实存在相应的文件。</p><p>方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在文件 a.txt 和 b.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> [ab].txt</span><br><span class="line"><span class="built_in">ls</span>: 无法访问<span class="string">&#x27;[ab].txt&#x27;</span>: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p>上面例子中，由于扩展后的文件不存在，<code>[ab].txt</code>就原样输出了，导致<code>ls</code>命名报错。</p><p>方括号扩展还有两种变体：<code>[^...]</code>和<code>[!...]</code>。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，<code>[^abc]</code>或<code>[!abc]</code>表示匹配除了<code>a</code>、<code>b</code>、<code>c</code>以外的字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在 aaa、bbb、aba 三个文件</span></span><br><span class="line">$ <span class="built_in">ls</span> ?[!a]?</span><br><span class="line">aba bbb</span><br></pre></td></tr></table></figure><p>上面命令中，<code>[!a]</code>表示文件名第二个字符不是<code>a</code>的文件名，所以返回了<code>aba</code>和<code>bbb</code>两个文件。</p><p>注意，如果需要匹配<code>[</code>字符，可以放在方括号内，比如<code>[[aeiou]</code>。如果需要匹配连字号<code>-</code>，只能放在方括号内部的开头或结尾，比如<code>[-aeiou]</code>或<code>[aeiou-]</code>。</p><h2 id="start-end-扩展"><a href="#start-end-扩展" class="headerlink" title="[start-end] 扩展"></a>[start-end] 扩展</h2><p>方括号扩展有一个简写形式<code>[start-end]</code>，表示匹配一个连续的范围。比如，<code>[a-c]</code>等同于<code>[abc]</code>，<code>[0-9]</code>匹配<code>[0123456789]</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt、b.txt 和 c.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> [a-c].txt</span><br><span class="line">a.txt</span><br><span class="line">b.txt</span><br><span class="line">c.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存在文件 report1.txt、report2.txt 和 report3.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> report[0-9].txt</span><br><span class="line">report1.txt</span><br><span class="line">report2.txt</span><br><span class="line">report3.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是一些常用简写的例子。</p><ul><li><code>[a-z]</code>：所有小写字母。</li><li><code>[a-zA-Z]</code>：所有小写字母与大写字母。</li><li><code>[a-zA-Z0-9]</code>：所有小写字母、大写字母与数字。</li><li><code>[abc]*</code>：所有以<code>a</code>、<code>b</code>、<code>c</code>字符之一开头的文件名。</li><li><code>program.[co]</code>：文件<code>program.c</code>与文件<code>program.o</code>。</li><li><code>BACKUP.[0-9][0-9][0-9]</code>：所有以<code>BACKUP.</code>开头，后面是三个数字的文件名。</li></ul><p>这种简写形式有一个否定形式<code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如，<code>[!a-zA-Z]</code>表示匹配非英文字母的字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> report[!1–3].txt</span><br><span class="line">report4.txt report5.txt</span><br></pre></td></tr></table></figure><p>上面代码中，<code>[!1-3]</code>表示排除1、2和3。</p><h2 id="大括号扩展"><a href="#大括号扩展" class="headerlink" title="大括号扩展"></a>大括号扩展</h2><p>大括号扩展<code>&#123;...&#125;</code>表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，<code>&#123;1,2,3&#125;</code>扩展成<code>1 2 3</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;1,2,3&#125;</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> d&#123;a,e,i,u,o&#125;g</span><br><span class="line">dag deg dig dug dog</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> Front-&#123;A,B,C&#125;-Back</span><br><span class="line">Front-A-Back Front-B-Back Front-C-Back</span><br></pre></td></tr></table></figure><p>注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> &#123;a,b,c&#125;.txt</span><br><span class="line"><span class="built_in">ls</span>: 无法访问<span class="string">&#x27;a.txt&#x27;</span>: 没有那个文件或目录</span><br><span class="line"><span class="built_in">ls</span>: 无法访问<span class="string">&#x27;b.txt&#x27;</span>: 没有那个文件或目录</span><br><span class="line"><span class="built_in">ls</span>: 无法访问<span class="string">&#x27;c.txt&#x27;</span>: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p>上面例子中，即使不存在对应的文件，<code>&#123;a,b,c&#125;</code>依然扩展成三个文件名，导致<code>ls</code>命令报了三个错误。</p><p>另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;1 , 2&#125;</span><br><span class="line">&#123;1 , 2&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。</p><p>逗号前面可以没有值，表示扩展的第一项为空。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> a.log&#123;,.bak&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="comment"># cp a.log a.log.bak</span></span><br></pre></td></tr></table></figure><p>大括号可以嵌套。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;j&#123;p,pe&#125;g,png&#125;</span><br><span class="line">jpg jpeg png</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b</span><br><span class="line">aA1b aA2b aB3b aB4b</span><br></pre></td></tr></table></figure><p>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> /bin/&#123;<span class="built_in">cat</span>,b*&#125;</span><br><span class="line">/bin/cat /bin/b2sum /bin/base32 /bin/base64 ... ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本等同于</span></span><br><span class="line">$ <span class="built_in">echo</span> /bin/cat;<span class="built_in">echo</span> /bin/b*</span><br></pre></td></tr></table></figure><p>上面例子中，会先进行大括号扩展，然后进行<code>*</code>扩展，等同于执行两条<code>echo</code>命令。</p><p>大括号可以用于多字符的模式，方括号不行（只能匹配单字符）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;<span class="built_in">cat</span>,dog&#125;</span><br><span class="line"><span class="built_in">cat</span> dog</span><br></pre></td></tr></table></figure><p>由于大括号扩展<code>&#123;...&#125;</code>不是文件名扩展，所以它总是会扩展的。这与方括号扩展<code>[...]</code>完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在 a.txt 和 b.txt</span></span><br><span class="line">$ <span class="built_in">echo</span> [ab].txt</span><br><span class="line">[ab].txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;a,b&#125;.txt</span><br><span class="line">a.txt b.txt</span><br></pre></td></tr></table></figure><p>上面例子中，如果不存在<code>a.txt</code>和<code>b.txt</code>，那么<code>[ab].txt</code>就会变成一个普通的文件名，而<code>&#123;a,b&#125;.txt</code>可以照样扩展。</p><h2 id="start-end-扩展-1"><a href="#start-end-扩展-1" class="headerlink" title="{start..end} 扩展"></a>{start..end} 扩展</h2><p>大括号扩展有一个简写形式<code>&#123;start..end&#125;</code>，表示扩展成一个连续序列。比如，<code>&#123;a..z&#125;</code>可以扩展成26个小写英文字母。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;a..c&#125;</span><br><span class="line">a b c</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> d&#123;a..d&#125;g</span><br><span class="line">dag dbg dcg ddg</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;1..4&#125;</span><br><span class="line">1 2 3 4</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> Number_&#123;1..5&#125;</span><br><span class="line">Number_1 Number_2 Number_3 Number_4 Number_5</span><br></pre></td></tr></table></figure><p>这种简写形式支持逆序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;c..a&#125;</span><br><span class="line">c b a</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;5..1&#125;</span><br><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure><p>注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;a1..3c&#125;</span><br><span class="line">&#123;a1..3c&#125;</span><br></pre></td></tr></table></figure><p>这种简写形式可以嵌套使用，形成复杂的扩展。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> .&#123;mp&#123;3..4&#125;,m4&#123;a,b,p,v&#125;&#125;</span><br><span class="line">.mp3 .mp4 .m4a .m4b .m4p .m4v</span><br></pre></td></tr></table></figure><p>大括号扩展的常见用途为新建一系列目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> &#123;2007..2009&#125;-&#123;01..12&#125;</span><br></pre></td></tr></table></figure><p>上面命令会新建36个子目录，每个子目录的名字都是”年份-月份“。</p><p>这个写法的另一个常见用途，是直接用于<code>for</code>循环。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..4&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>上面例子会循环4次。</p><p>如果整数前面有前导<code>0</code>，扩展输出的每一项都有前导<code>0</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;01..5&#125;</span><br><span class="line">01 02 03 04 05</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;001..5&#125;</span><br><span class="line">001 002 003 004 005</span><br></pre></td></tr></table></figure><p>这种简写形式还可以使用第二个双点号（<code>start..end..step</code>），用来指定扩展的步长。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;0..8..2&#125;</span><br><span class="line">0 2 4 6 8</span><br></pre></td></tr></table></figure><p>上面代码将<code>0</code>扩展到<code>8</code>，每次递增的长度为<code>2</code>，所以一共输出5个数字。</p><p>多个简写形式连用，会有循环处理的效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;a..c&#125;&#123;1..3&#125;</span><br><span class="line">a1 a2 a3 b1 b2 b3 c1 c2 c3</span><br></pre></td></tr></table></figure><h2 id="变量扩展"><a href="#变量扩展" class="headerlink" title="变量扩展"></a>变量扩展</h2><p>Bash 将美元符号<code>$</code>开头的词元视为变量，将其扩展成变量值，详见《Bash 变量》一章。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p>变量名除了放在美元符号后面，也可以放在<code>$&#123;&#125;</code>里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;SHELL&#125;</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p><code>$&#123;!string*&#125;</code>或<code>$&#123;!string@&#125;</code>返回所有匹配给定字符串<code>string</code>的变量名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!S*&#125;</span></span><br><span class="line">SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK</span><br></pre></td></tr></table></figure><p>上面例子中，<code>$&#123;!S*&#125;</code>扩展成所有以<code>S</code>开头的变量名。</p><h2 id="子命令扩展"><a href="#子命令扩展" class="headerlink" title="子命令扩展"></a>子命令扩展</h2><p><code>$(...)</code>可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(<span class="built_in">date</span>)</span><br><span class="line">Tue Jan 28 00:01:13 CST 2020</span><br></pre></td></tr></table></figure><p>上面例子中，<code>$(date)</code>返回<code>date</code>命令的运行结果。</p><p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> `<span class="built_in">date</span>`</span><br><span class="line">Tue Jan 28 00:01:13 CST 2020</span><br></pre></td></tr></table></figure><p><code>$(...)</code>可以嵌套，比如<code>$(ls $(pwd))</code>。</p><h2 id="算术扩展"><a href="#算术扩展" class="headerlink" title="算术扩展"></a>算术扩展</h2><p><code>$((...))</code>可以扩展成整数运算的结果，详见《Bash 的算术运算》一章。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((<span class="number">2</span> + <span class="number">2</span>))</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p><code>[[:class:]]</code>表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。</p><ul><li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li><li><code>[[:alpha:]]</code>：匹配任意英文字母</li><li><code>[[:blank:]]</code>：空格和 Tab 键。</li><li><code>[[:cntrl:]]</code>：ASCII 码 0-31 的不可打印字符。</li><li><code>[[:digit:]]</code>：匹配任意数字 0-9。</li><li><code>[[:graph:]]</code>：A-Z、a-z、0-9 和标点符号。</li><li><code>[[:lower:]]</code>：匹配任意小写字母 a-z。</li><li><code>[[:print:]]</code>：ASCII 码 32-127 的可打印字符。</li><li><code>[[:punct:]]</code>：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。</li><li><code>[[:space:]]</code>：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。</li><li><code>[[:upper:]]</code>：匹配任意大写字母 A-Z。</li><li><code>[[:xdigit:]]</code>：16进制字符（A-F、a-f、0-9）。</li></ul><p>请看下面的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> [[:upper:]]*</span><br></pre></td></tr></table></figure><p>上面命令输出所有大写字母开头的文件名。</p><p>字符类的第一个方括号后面，可以加上感叹号<code>!</code>，表示否定。比如，<code>[![:digit:]]</code>匹配所有非数字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> [![:digit:]]*</span><br></pre></td></tr></table></figure><p>上面命令输出所有不以数字开头的文件名。</p><p>字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在以大写字母开头的文件</span></span><br><span class="line">$ <span class="built_in">echo</span> [[:upper:]]*</span><br><span class="line">[[:upper:]]*</span><br></pre></td></tr></table></figure><p>上面例子中，由于没有可匹配的文件，字符类就原样输出了。</p><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><p>通配符有一些使用注意点，不可不知。</p><p><strong>（1）通配符是先解释，再执行。</strong></p><p>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> a*.txt</span><br><span class="line">ab.txt</span><br></pre></td></tr></table></figure><p>上面命令的执行过程是，Bash 先将<code>a*.txt</code>扩展成<code>ab.txt</code>，然后再执行<code>ls ab.txt</code>。</p><p><strong>（2）文件名扩展在不匹配时，会原样输出。</strong></p><p>文件名扩展在没有可匹配的文件时，会原样输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在 r 开头的文件名</span></span><br><span class="line">$ <span class="built_in">echo</span> r*</span><br><span class="line">r*</span><br></pre></td></tr></table></figure><p>上面代码中，由于不存在<code>r</code>开头的文件名，<code>r*</code>会原样输出。</p><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> *.csv</span><br><span class="line"><span class="built_in">ls</span>: *.csv: No such file or directory</span><br></pre></td></tr></table></figure><p>另外，前面已经说过，大括号扩展<code>&#123;...&#125;</code>不是文件名扩展。</p><p><strong>（3）只适用于单层路径。</strong></p><p>所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code>或<code>*</code>这样的通配符，不能匹配路径分隔符（<code>/</code>）。</p><p>如果要匹配子目录里面的文件，可以写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> */*.txt</span><br></pre></td></tr></table></figure><p>Bash 4.0 新增了一个<code>globstar</code>参数，允许<code>**</code>匹配零个或多个子目录，详见后面<code>shopt</code>命令的介绍。</p><p><strong>（4）文件名可以使用通配符。</strong></p><p>Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号或双引号里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> <span class="string">&#x27;fo*&#x27;</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">fo*</span><br></pre></td></tr></table></figure><p>上面代码创建了一个<code>fo*</code>文件，这时<code>*</code>就是文件名的一部分。</p><h2 id="量词语法"><a href="#量词语法" class="headerlink" title="量词语法"></a>量词语法</h2><p>量词语法用来控制模式匹配的次数。它只有在 Bash 的<code>extglob</code>参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> extglob</span><br><span class="line">extglob        	on</span><br></pre></td></tr></table></figure><p>如果<code>extglob</code>参数是关闭的，可以用下面的命令打开。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s extglob</span><br></pre></td></tr></table></figure><p>量词语法有下面几个。</p><ul><li><code>?(pattern-list)</code>：模式匹配零次或一次。</li><li><code>*(pattern-list)</code>：模式匹配零次或多次。</li><li><code>+(pattern-list)</code>：模式匹配一次或多次。</li><li><code>@(pattern-list)</code>：只匹配一次模式。</li><li><code>!(pattern-list)</code>：匹配给定模式以外的任何内容。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> abc?(.)txt</span><br><span class="line">abctxt abc.txt</span><br></pre></td></tr></table></figure><p>上面例子中，<code>?(.)</code>匹配零个或一个点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> abc?(def)</span><br><span class="line">abc abcdef</span><br></pre></td></tr></table></figure><p>上面例子中，<code>?(def)</code>匹配零个或一个<code>def</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> abc@(.txt|.php)</span><br><span class="line">abc.php abc.txt</span><br></pre></td></tr></table></figure><p>上面例子中，<code>@(.txt|.php)</code>匹配文件有且只有一个<code>.txt</code>或<code>.php</code>后缀名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> abc+(.txt)</span><br><span class="line">abc.txt abc.txt.txt</span><br></pre></td></tr></table></figure><p>上面例子中，<code>+(.txt)</code>匹配文件有一个或多个<code>.txt</code>后缀名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> a!(b).txt</span><br><span class="line">a.txt abb.txt ac.txt</span><br></pre></td></tr></table></figure><p>上面例子中，<code>!(b)</code>表示匹配单个字母<code>b</code>以外的任意内容，所以除了<code>ab.txt</code>以外，其他文件名都能匹配。</p><p>量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有 abc 开头的文件名</span></span><br><span class="line">$ <span class="built_in">ls</span> abc?(def)</span><br><span class="line"><span class="built_in">ls</span>: 无法访问<span class="string">&#x27;abc?(def)&#x27;</span>: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p>上面例子中，由于没有可匹配的文件，<code>abc?(def)</code>就原样输出，导致<code>ls</code>命令报错。</p><h2 id="shopt-命令"><a href="#shopt-命令" class="headerlink" title="shopt 命令"></a>shopt 命令</h2><p><code>shopt</code>命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。</p><p><code>shopt</code>命令的使用方法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> -s [optionname]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> -u [optionname]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询某个参数关闭还是打开</span></span><br><span class="line">$ <span class="built_in">shopt</span> [optionname]</span><br></pre></td></tr></table></figure><p><strong>（1）dotglob 参数</strong></p><p><code>dotglob</code>参数可以让扩展结果包括隐藏文件（即点开头的文件）。</p><p>正常情况下，扩展结果不包括隐藏文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> *</span><br><span class="line">abc.txt</span><br></pre></td></tr></table></figure><p>打开<code>dotglob</code>，就会包括隐藏文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s dotglob</span><br><span class="line">$ <span class="built_in">ls</span> *</span><br><span class="line">abc.txt .config</span><br></pre></td></tr></table></figure><p><strong>（2）nullglob 参数</strong></p><p><code>nullglob</code>参数可以让通配符不匹配任何文件名时，返回空字符。</p><p>默认情况下，通配符不匹配任何文件名时，会保持不变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> b*</span><br><span class="line"><span class="built_in">rm</span>: 无法删除<span class="string">&#x27;b*&#x27;</span>: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p>上面例子中，由于当前目录不包括<code>b</code>开头的文件名，导致<code>b*</code>不会发生文件名扩展，保持原样不变，所以<code>rm</code>命令报错没有<code>b*</code>这个文件。</p><p>打开<code>nullglob</code>参数，就可以让不匹配的通配符返回空字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s nullglob</span><br><span class="line">$ <span class="built_in">rm</span> b*</span><br><span class="line"><span class="built_in">rm</span>: 缺少操作数</span><br></pre></td></tr></table></figure><p>上面例子中，由于没有<code>b*</code>匹配的文件名，所以<code>rm b*</code>扩展成了<code>rm</code>，导致报错变成了”缺少操作数“。</p><p><strong>（3）failglob 参数</strong></p><p><code>failglob</code>参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s failglob</span><br><span class="line">$ <span class="built_in">rm</span> b*</span><br><span class="line">bash: 无匹配: b*</span><br></pre></td></tr></table></figure><p>上面例子中，打开<code>failglob</code>以后，由于<code>b*</code>不匹配任何文件名，Bash 直接报错了，不再让<code>rm</code>命令去处理。</p><p><strong>（4）extglob 参数</strong></p><p><code>extglob</code>参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> extglob</span><br><span class="line">extglob        	on</span><br></pre></td></tr></table></figure><p>它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -u extglob</span><br></pre></td></tr></table></figure><p><strong>（5）nocaseglob 参数</strong></p><p><code>nocaseglob</code>参数可以让通配符扩展不区分大小写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s nocaseglob</span><br><span class="line">$ <span class="built_in">ls</span> /windows/program*</span><br><span class="line">/windows/ProgramData</span><br><span class="line">/windows/Program Files</span><br><span class="line">/windows/Program Files (x86)</span><br></pre></td></tr></table></figure><p>上面例子中，打开<code>nocaseglob</code>以后，<code>program*</code>就不区分大小写了，可以匹配<code>ProgramData</code>等。</p><p><strong>（6）globstar 参数</strong></p><p><code>globstar</code>参数可以使得<code>**</code>匹配零个或多个子目录。该参数默认是关闭的。</p><p>假设有下面的文件结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.txt</span><br><span class="line">sub1/b.txt</span><br><span class="line">sub1/sub2/c.txt</span><br></pre></td></tr></table></figure><p>上面的文件结构中，顶层目录、第一级子目录<code>sub1</code>、第二级子目录<code>sub1\sub2</code>里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来？</p><p>默认情况下，只能写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> *.txt */*.txt */*/*.txt</span><br><span class="line">a.txt  sub1/b.txt  sub1/sub2/c.txt</span><br></pre></td></tr></table></figure><p>这是因为<code>*</code>只匹配当前目录，如果要匹配子目录，只能一层层写出来。</p><p>打开<code>globstar</code>参数以后，<code>**</code>匹配零个或多个子目录。因此，<code>**/*.txt</code>就可以得到想要的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s globstar</span><br><span class="line">$ <span class="built_in">ls</span> **/*.txt</span><br><span class="line">a.txt  sub1/b.txt  sub1/sub2/c.txt</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://medium.com/@leedowthwaite/why-most-people-only-think-they-understand-wildcards-63bb9c2024ab">Think You Understand Wildcards? Think Again</a></li><li><a target="_blank" rel="noopener" href="https://appcodelabs.com/advanced-wildcard-patterns-most-people-dont-know">Advanced Wildcard Patterns Most People Don’t Know</a></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Shell-%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> Shell 学习</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2016/03/13/Bash%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" rel="prev" title="Bash 的基本语法"><i class="fa fa-chevron-left"></i> Bash 的基本语法</a></div><div class="post-nav-item"><a href="/2016/03/21/%E5%BC%95%E5%8F%B7%E5%92%8C%E8%BD%AC%E4%B9%89/" rel="next" title="引号和转义">引号和转义 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i></i> </span><span class="author" itemprop="copyrightHolder"></span></div><script color="0,0,0" opacity="0.75" zindex="-1" count="60" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script></body></html>